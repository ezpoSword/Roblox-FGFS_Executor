using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using System.Windows.Forms;
using CloudyApi;
using Microsoft.VisualBasic;
using Newtonsoft.Json;

namespace WindowsFormsApp1
{
    public partial class FGFS_EXECUTOR : Form
    {
        public FGFS_EXECUTOR()
        {
            InitializeComponent();
            this.Load += FGFS_EXECUTOR_Load;
            Api.misc.disableSecurity();
            Api.External.RegisterExecutor("FGFS EXECUTOR V3");
            this.Load += async (s, e) => await CheckVersionAsync();
            Dictionary<Control, Point> originalPositions = new Dictionary<Control, Point>();
            List<Control> controlsToAnimate = new List<Control>();

            // Konsolu ilk açılana kadar gizli yapabiliriz
            richTextBoxConsole.Visible = false;

            // Konsolu yazılamaz yapalım
            richTextBoxConsole.ReadOnly = true;

            // Tuş yakalama için formda KeyPreview açık
            this.KeyPreview = true;

            this.KeyDown += Form1_KeyDown;
        }
        private async void FGFS_EXECUTOR_Load(object sender, EventArgs e)
        {
            await Task.Delay(100);
            await DownloadAndVerifyEditorAsync();
            
        }


        Dictionary<Control, Point> originalPositions = new Dictionary<Control, Point>();
        List<Control> controlsToAnimate = new List<Control>();








        private async Task CheckVersionAsync()
        {
            string currentVersion = "0.0.1"; // Senin yerel versiyonun
            string url = "https://raw.githubusercontent.com/ezpoSword/Roblox-FGFS_Executor/refs/heads/master/VRS5434";

            try
            {
                string onlineVersion;

                using (HttpClient client = new HttpClient())
                {
                    client.Timeout = TimeSpan.FromSeconds(3);
                    onlineVersion = await client.GetStringAsync(url);
                }

                if (string.IsNullOrWhiteSpace(onlineVersion))
                {
                    SetLabel("Error", Color.Gray);
                    return;
                }

                onlineVersion = onlineVersion.Trim();

                int diff = CompareVersionSimilarity(currentVersion, onlineVersion);

                if (onlineVersion == currentVersion)
                {
                    SetLabel("New", Color.Green);
                }
                else if (diff <= 2) // Küçük farkları Meh olarak kabul et
                {
                    SetLabel("Meh", Color.Orange);
                }
                else
                {
                    SetLabel("Old", Color.Red);
                }
            }
            catch (Exception ex)
            {
                SetLabel("Error", Color.Gray);
                Console.WriteLine("Version check failed: " + ex.Message);
            }
        }

        private int CompareVersionSimilarity(string local, string remote)
        {
            var localParts = local.Split('.').Select(x => int.TryParse(x, out var n) ? n : 0).ToArray();
            var remoteParts = remote.Split('.').Select(x => int.TryParse(x, out var n) ? n : 0).ToArray();

            int length = Math.Max(localParts.Length, remoteParts.Length);
            int difference = 0;

            for (int i = 0; i < length; i++)
            {
                int localVal = i < localParts.Length ? localParts[i] : 0;
                int remoteVal = i < remoteParts.Length ? remoteParts[i] : 0;
                difference += Math.Abs(localVal - remoteVal);
            }

            return difference;
        }

        private void SetLabel(string text, Color color)
        {
            if (label5.InvokeRequired)
            {
                label5.Invoke(new Action(() =>
                {
                    label5.Text = text;
                    label5.ForeColor = color;
                }));
            }
            else
            {
                label5.Text = text;
                label5.ForeColor = color;
            }
        }







        DateTime lastInjectAttempt = DateTime.MinValue; // Form sınıfının içinde tanımla

        public Dictionary<Control, Point> OriginalPositions { get => OriginalPositions1; set => OriginalPositions1 = value; }
        public List<Control> ControlsToAnimate { get => ControlsToAnimate1; set => ControlsToAnimate1 = value; }
        public DateTime LastInjectAttempt { get => LastInjectAttempt1; set => LastInjectAttempt1 = value; }
        public Dictionary<Control, Point> OriginalPositions1 { get => OriginalPositions2; set => OriginalPositions2 = value; }
        public List<Control> ControlsToAnimate1 { get => ControlsToAnimate2; set => ControlsToAnimate2 = value; }
        public DateTime LastInjectAttempt1 { get => LastInjectAttempt2; set => LastInjectAttempt2 = value; }
        public Dictionary<Control, Point> OriginalPositions2 { get => OriginalPositions3; set => OriginalPositions3 = value; }
        public List<Control> ControlsToAnimate2 { get => ControlsToAnimate3; set => ControlsToAnimate3 = value; }
        public DateTime LastInjectAttempt2 { get => LastInjectAttempt3; set => LastInjectAttempt3 = value; }
        public Dictionary<Control, Point> OriginalPositions3 { get => originalPositions; set => originalPositions = value; }
        public List<Control> ControlsToAnimate3 { get => controlsToAnimate; set => controlsToAnimate = value; }
        public DateTime LastInjectAttempt3 { get => lastInjectAttempt; set => lastInjectAttempt = value; }

        private async Task<bool> InjectRobloxAsync(int maxAttempts = 10, int baseDelayMs = 1000)
        {
            if ((DateTime.Now - LastInjectAttempt).TotalSeconds < 5)
            {
                ShowWindowsNotification("Time Limit", "This action is time-limited. Please wait 5 seconds or wait for Roblox to inject!");
                return false;
            }

            LastInjectAttempt = DateTime.Now;

            for (int attempt = 1; attempt <= maxAttempts; attempt++)
            {
                try
                {
                    bool isInjected = Api.External.IsInjected();

                    if (isInjected)
                    {
                        Api.External.execute(
                            "print(\"FGFS EXECUTOR V3 [NEW]\")\n" +
                            "print(\"----------------\")\n" +
                            "print(\"is inject?: ✔\")\n" +
                            "print(unc: 70 - 90)\n" +
                            "print(\"made by: FGFS CHEAT GROUP\")\n" +
                            "print(\"----------------\")\n" +
                            "warn(\"-10101010010101-\")"
                        );

                        ShowWindowsNotification("Injection Success", $"Injection successful on attempt {attempt}!");
                        return true;
                    }
                    else
                    {

                    }
                }
                catch (Exception ex)
                {
                    // Hata mesajını kaydet, göster veya logla
                    ShowWindowsNotification("Injection Error", $"Attempt {attempt} failed with error: {ex.Message}");
                }

                // Artan bekleme süresi (exponential backoff)
                int delay = baseDelayMs * attempt;
                await Task.Delay(delay);
            }

            ShowWindowsNotification("Timeout Warning", "Executor failed to connect within the timeout period!");
            return false;
        }








        private void AnimateButtonSmooth(Guna.UI2.WinForms.Guna2GradientButton button, Point targetLocation, Size targetSize, int interval = 30, int steps = 20)
        {
            Timer timer = new Timer();
            timer.Interval = interval;

            // Başlangıç değerleri
            Size startSize = button.Size;
            Point startLocation = button.Location;
            string originalText = button.Text;

            int currentStep = 0;

            timer.Tick += (s, e) =>
            {
                currentStep++;
                if (currentStep > steps)
                {
                    // Animasyon bitti, son hali kesinleştir
                    button.Size = targetSize;
                    button.Location = targetLocation;
                    button.Text = "";
                    timer.Stop();
                    timer.Dispose();
                    return;
                }

                // Her adımda yeni boyut hesapla (lineer interpolasyon)
                int newWidth = Lerp(startSize.Width, targetSize.Width, currentStep, steps);
                int newHeight = Lerp(startSize.Height, targetSize.Height, currentStep, steps);
                button.Size = new Size(newWidth, newHeight);

                // Her adımda yeni konumu hesapla (lineer interpolasyon)
                int newX = Lerp(startLocation.X, targetLocation.X, currentStep, steps);
                int newY = Lerp(startLocation.Y, targetLocation.Y, currentStep, steps);
                button.Location = new Point(newX, newY);

                // Yazıyı teker teker sil (her 2. adımda 1 harf sil)
                if (currentStep % 2 == 0 && button.Text.Length > 0)
                {
                    button.Text = button.Text.Substring(0, button.Text.Length - 1);
                }
            };

            timer.Start();
        }

        // Yardımcı lineer interpolasyon fonksiyonu
        private int Lerp(int start, int end, int step, int totalSteps)
        {
            return start + (end - start) * step / totalSteps;
        }








        private void FadePanelToBlack(Panel panel)
        {
            Timer fadeTimer = new Timer();
            int fadeStep = 0;

            fadeTimer.Interval = 50;
            fadeTimer.Tick += (s, e) =>
            {
                if (fadeStep <= 255)
                {
                    panel.BackColor = Color.FromArgb(fadeStep, 0, 0, 0);
                    fadeStep += 5;
                }
                else
                {
                    fadeTimer.Stop();
                }
            };

            panel.BackColor = Color.FromArgb(0, 0, 0, 0);
            fadeTimer.Start();
        }

        private async Task AnimateControlToOriginalPosition(Control ctrl, TimeSpan duration)
        {
            Point start = ctrl.Location;
            Point end = OriginalPositions[ctrl];

            int steps = 70; // daha smooth
            int delay = (int)(duration.TotalMilliseconds / steps);

            for (int i = 1; i <= steps; i++)
            {
                int newX = Lerp(start.X, end.X, i / (float)steps);
                int newY = Lerp(start.Y, end.Y, i / (float)steps);
                ctrl.Location = new Point(newX, newY);
                await Task.Delay(delay);
            }

            ctrl.Location = end;
        }

        private int Lerp(int start, int end, float t)
        {
            return (int)(start + (end - start) * t);
        }



        private async Task DownloadAndVerifyEditorAsync()
        {
            string downloadUrl = "https://github.com/ezpoSword/FcuterGFS/raw/master/Editor.zip";
            string tempZipPath = Path.Combine(Path.GetTempPath(), "editor.zip");
            string extractPath = Path.Combine(Application.StartupPath, "ExtractedEditor");
            string finalEditorPath = Path.Combine(Application.StartupPath, "Editor");

            try
            {
                WhatGoingLabel.Text = "Checking existing files...";

                // Önceden var olan dosyaları kontrol et
                if (Directory.Exists(finalEditorPath) &&
                    Directory.GetFiles(finalEditorPath, "*", SearchOption.AllDirectories).Length > 0)
                {
                    WhatGoingLabel.Text = "Files already verified. Launching...";
                    await AnimateProgressBar(LoadingProgressBar.Value, 100);
                    await Task.Delay(1000);
                    LoadingPanel.Visible = false;
                    MenuPanel.Visible = true;
                    MenuPanel.BringToFront();
                    MenuPanel.Refresh();
                    MenuPanel.Size = this.ClientSize;
                    await InitializeAsync();

                    return;
                }

                WhatGoingLabel.Text = "Downloading and verifying files...";
                await AnimateProgressBar(0, 30);

                using (WebClient client = new WebClient())
                {
                    await client.DownloadFileTaskAsync(new Uri(downloadUrl), tempZipPath);
                }

                await AnimateProgressBar(30, 50);

                if (Directory.Exists(extractPath))
                    Directory.Delete(extractPath, true);

                ZipFile.ExtractToDirectory(tempZipPath, extractPath);
                File.Delete(tempZipPath);

                await AnimateProgressBar(50, 70);

                if (Directory.Exists(finalEditorPath))
                    Directory.Delete(finalEditorPath, true);

                string[] subDirs = Directory.GetDirectories(extractPath);
                if (subDirs.Length == 0)
                    throw new Exception("Extracted ZIP does not contain a folder.");

                // Kopyala
                CopyDirectory(subDirs[0], finalEditorPath);

                await AnimateProgressBar(70, 90);

                bool hasFiles = Directory.GetFiles(finalEditorPath, "*", SearchOption.AllDirectories).Length > 0;
                if (hasFiles)
                {
                    WhatGoingLabel.Text = "Files verified. Launching...";
                    await AnimateProgressBar(90, 100);
                    await Task.Delay(1000);
                    LoadingPanel.Visible = false;
                    MenuPanel.Visible = true;
                    MenuPanel.BringToFront();
                    MenuPanel.Refresh();
                    MenuPanel.Size = this.ClientSize;
                    await InitializeAsync();
                }
                else
                {
                    WhatGoingLabel.Text = "File verification failed!";
                }
            }
            catch (Exception ex)
            {
                WhatGoingLabel.Text = "Error: " + ex.Message;
            }
        }

        private async Task InitializeAsync()
        {
            // Kontrolleri sırayla ekle
            ControlsToAnimate.AddRange(new Control[] {
        pictureBox1, linkLabel1, label1, Version, Minimaze,
        CloseAppButton, Execute, CloseRBLX, ReadyScript,
        ClearEditor, OpenFolder, SaveScript, Inject
    });

            // Pozisyonları kaydet ve görünmez + ekran dışına taşı
            int formHeight = this.Height;
            foreach (var ctrl in ControlsToAnimate)
            {
                OriginalPositions[ctrl] = ctrl.Location;
                ctrl.Location = new Point(ctrl.Location.X, formHeight + 100);
                ctrl.Visible = false;
            }

            // Fade ve WebView işlemleri
            FadePanelToBlack(MenuPanel);
            await Task.Delay(3000);

            try
            {
                await Editor.EnsureCoreWebView2Async(null);

                string path = Path.Combine(Application.StartupPath, "Editor", "index.html");

                if (!File.Exists(path))
                {
                    MessageBox.Show($"LAN DOSYA BULUNAMADI! PATH: {path}", "Dosya Hatası", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                Editor.CoreWebView2.Navigate(new Uri(path).AbsoluteUri);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing WebView2: {ex.Message}", "Initialization Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            // Kontrolleri sırayla yumuşak animasyonla yukarı taşı
            // Kontrolleri sırayla yumuşak animasyonla yukarı taşı
            foreach (var ctrl in ControlsToAnimate)
            {
                ctrl.Visible = true;

                Point start = ctrl.Location;
                Point end = OriginalPositions[ctrl];
                int steps = 13;
                int delay = 3; // 10ms * 20 = 200ms

                for (int i = 1; i <= steps; i++)
                {
                    float t = i / (float)steps;
                    int newX = (int)(start.X + (end.X - start.X) * t);
                    int newY = (int)(start.Y + (end.Y - start.Y) * t);
                    ctrl.Location = new Point(newX, newY);
                    await Task.Delay(delay);
                }

                ctrl.Location = end; // pozisyonu sabitle
                await Task.Delay(23); // sıradaki kontrolle arasında hafif bekleme
            }


            await Task.Delay(1000);
            AnimateButtonSmooth(CloseRBLX, new Point(57, 281), new Size(45, 45));
            AnimateButtonSmooth(ReadyScript, new Point(108, 281), new Size(45, 45));
        }



        private async Task AnimateProgressBar(int start, int end)
        {
            for (int i = start; i <= end; i++)
            {
                if (i >= LoadingProgressBar.Minimum && i <= LoadingProgressBar.Maximum)
                {
                    LoadingProgressBar.Value = i;
                }
                await Task.Delay(10);
            }
        }

        private void CopyDirectory(string sourceDir, string destinationDir)
        {
            Directory.CreateDirectory(destinationDir);

            foreach (var file in Directory.GetFiles(sourceDir))
            {
                string destFile = Path.Combine(destinationDir, Path.GetFileName(file));
                File.Copy(file, destFile, true);
            }

            foreach (var dir in Directory.GetDirectories(sourceDir))
            {
                string destDir = Path.Combine(destinationDir, Path.GetFileName(dir));
                CopyDirectory(dir, destDir);
            }
        }

        private void LoadingProgressBar_ValueChanged(object sender, EventArgs e)
        {
            // Gerekirse özelleştirme yapılabilir
        }

        private void Loadingico_Click(object sender, EventArgs e)
        {
            // Boş bırakılmış
        }

        private async void Inject_Click(object sender, EventArgs e)
        {
            Api.External.inject();
            bool success = await InjectRobloxAsync();
        }

        private async void Execute_Click(object sender, EventArgs e)
        {
            if (Api.External.IsInjected())
            {
                Api.External.execute(
                JsonConvert.DeserializeObject<string>(
                await Editor.ExecuteScriptAsync("GetText();")
                )
                );
            }
            else
            {
                ShowWindowsNotification("execute error!", "Please inject roblox");
            }
        }
















        private void ShowWindowsNotification(string title, string message)
        {
            string appName = "FGFS CHT Executor";

            NotifyIcon notifyIcon = new NotifyIcon()
            {
                Icon = SystemIcons.Information,
                Visible = true,
                BalloonTipTitle = $"{appName} - {title}",
                BalloonTipText = message
            };

            notifyIcon.ShowBalloonTip(3000);

            System.Threading.Thread.Sleep(3500);

            notifyIcon.Dispose();
        }

        private async void SaveScript_Click(object sender, EventArgs e)
        {
            // Create the "Script" folder if it doesn't exist
            string scriptFolderPath = Path.Combine(Application.StartupPath, "Script");
            if (!Directory.Exists(scriptFolderPath))
            {
                Directory.CreateDirectory(scriptFolderPath);
            }

            // Ask user for the script file name
            string fileName = Microsoft.VisualBasic.Interaction.InputBox(
                "Enter the name for the Lua script file:",
                "Save Script",
                "NewScript"
            );

            if (string.IsNullOrWhiteSpace(fileName))
            {
                MessageBox.Show("No file name was entered!", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string filePath = Path.Combine(scriptFolderPath, fileName + ".lua");

            try
            {
                // Get the text content from the WebView2 Editor
                string code = JsonConvert.DeserializeObject<string>(
                    await Editor.ExecuteScriptAsync("GetText();")
                );

                // Save the content to a .lua file
                File.WriteAllText(filePath, code);
                MessageBox.Show($"Script was successfully saved:\n{filePath}", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"An error occurred while saving the script:\n{ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private async void OpenFolder_Click(object sender, EventArgs e)
        {

            string scriptFolderPath = Path.Combine(Application.StartupPath, "Script");

            if (!Directory.Exists(scriptFolderPath))
            {
                MessageBox.Show("Script folder does not exist!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            var luaFiles = Directory.GetFiles(scriptFolderPath, "*.lua");

            if (luaFiles.Length == 0)
            {
                MessageBox.Show("No .lua files found in the Script folder.", "Info", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Build the list of options
            string promptText = "Choose a script to load:\n\n";
            for (int i = 0; i < luaFiles.Length; i++)
            {
                string name = Path.GetFileName(luaFiles[i]);
                promptText += $"{i + 1}. {name}\n";
            }

            string input = Interaction.InputBox(promptText, "Select Script", "1");

            if (!int.TryParse(input, out int selection) || selection < 1 || selection > luaFiles.Length)
            {
                MessageBox.Show("Invalid selection!", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string selectedFilePath = luaFiles[selection - 1];
            string fileContent = File.ReadAllText(selectedFilePath);

            // Escape content and inject into Monaco editor
            string escapedContent = JsonConvert.SerializeObject(fileContent);
            await Editor.ExecuteScriptAsync($"editor.setValue({escapedContent});");
        }

        private async void ClearEditor_Click(object sender, EventArgs e)
        {
            await Editor.ExecuteScriptAsync("editor.setValue('');");
        }

        private void CloseAppButton_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        private void Minimaze_Click(object sender, EventArgs e)
        {
            this.WindowState = FormWindowState.Minimized;
        }

        private void CloseRBLX_Click(object sender, EventArgs e)
        {
            Api.misc.killRoblox();
        }

        private void LoadingPanel_Paint(object sender, PaintEventArgs e)
        {

        }

        private void label5_Click(object sender, EventArgs e)
        {

        }
        private void PowerShellConsoleOpen_Click(object sender, EventArgs e)
        {
            richTextBoxConsole.Visible = true; 
            richTextBoxConsole.Clear();
            SendConsole("PowerShell benzeri konsol açıldı!\n", Color.LightGray);
        }

        public void SendConsole(string message)
        {
            SendConsole(message, Color.White);
        }

        public void SendConsole(string message, Color color)
        {
            richTextBoxConsole.SelectionStart = richTextBoxConsole.TextLength; 
            richTextBoxConsole.SelectionLength = 0;

            richTextBoxConsole.SelectionColor = color;
            richTextBoxConsole.AppendText(message);
            richTextBoxConsole.SelectionColor = richTextBoxConsole.ForeColor;

            richTextBoxConsole.ScrollToCaret();
        }

        public void SendConsole(string part1, Color color1, string part2, Color color2)
        {
            SendConsole(part1, color1);
            SendConsole(part2, color2);
        }

        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.F5)
            {
                richTextBoxConsole.Clear();
                SendConsole("Konsol temizlendi.\n", Color.Yellow);
                e.Handled = true;
            }
        }
    }
}
